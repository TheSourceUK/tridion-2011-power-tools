#summary Coding guidelines used during development of Tridion Content Manager Explorer 2011.
#labels Phase-Implementation

= Introduction =

The following is a modified version of the coding guidelines that were used during development of the (client-side) 2011 CME and its underlying core framework. 

They should also serve as guidelines for development of extensions such as the PowerTools.


= !JavaScript and HTML guidelines =

== Code organization ==

  * Use a separate file for each class you write.
  * Name a file after the class it defines (excluding the namespace).    
    * For instance ''Control.js'' for a file containing a definition of ''Tridion.Control'' class.

== Namespaces ==

  * Use namespace prefixes for the classes you write.
  * Include namespace definition at the top of the file that uses that namespace. _Type.registerNamespace_ ensures that a namespace prefix exists before you attempt to use it.
  * Namespaces should use Pascal Case 
{{{ 
Type.registerNamespace("Tridion.MessageCenter");
}}}

== Functions ==

  * Name every function. This enables the stack trace to display actual names for function calls, instead of a series of anonymous() calls, which is a great help during debugging.
  * Use camel-case for all function names and arguments. This includes get and set functions. 

{{{
this.methodName = function Class$methodName(paramName)
{
	...
}
}}}
  * ''id'' in function names should be capitalized like ''Id'', not ''ID''. For instance: ''getId()''
  * Functions that are used as callback functions or event handlers should be named using the following format: on[''Object''][''Event''], where ''Object'' is a name that identifies an object. For instance, _onButtonClick()_ or _onPageLoad()_.
  * Functions do not need a _return_ statement at the end if they do not return a value.
  * All function definitions should have a semicolon at the end
  * 
{{{
function thisFunctionName() 
{ 
   ... 
};
}}}

This is to prevent problems when the next statement is started with an opening parenthesis, for example the following code will generate an error:

{{{
MyClass = function () {}

(function()
{
	var item = new MyClass();
})();
}}}
 , while the following code will run fine: 
{{{
MyClass = function () {};

(function()
{
	var item = new MyClass();
})();
}}}

== Constants ==

All constant names should be in UPPERCASE <code>
Tridion.Constants.PublishPriority =
{
	LOW : 2,
	NORMAL : 4,
	HIGH : 6
};
</code>

== Variables ==

  * Avoid global variables
  * All global variables should be under a Tridion.{{{*}}} namespace
  * Use camel-case for local variables, object properties, and function arguments.<br>

Usage: <code>
var variableName = "";
var otherVariableName = false;
</code> <br>

  * Have a single ''var'' definitions for a local variable:

WRONG: <code>
function func(flag)
{
	if (flag)
	{
		var result = true;
	}
	else
	{
		var result = false;
	}
	return result;
}
</code> RIGHT: <code>
function func(flag)
{
	var result;
	if (flag)
	{
		result = true;
	}
	else
	{
		result = false;
	}
	return result;
}
</code>

== Classes/Objects ==

  * Classes (constructors) should use Pascal Case
  * All properties used by the class should be explicitly listed and initialized in the constructor, even if the initialization value is ''undefined''
  * ''Private'' methods (methods that are intended for internal use by the class itself and should not be considered as part of the API of the class) should start with an underscore character:

<code>
function ClassA()
{
}

ClassA.prototype.public = function ClassA$public()
{
}

ClassA.prototype.`_`private= function ClassA$`_`private()
{
}
</code>

  * When creating a class constructor prefereably use ''prototype'' object to define methods of the class. If a single instance of the class is going to be created at a time (i.e. a singleton pattern), closures may be used as well

Using ''prototype'': <code>
function ClassA()
{
}

ClassA.prototype.method1 = function ClassA$method1()
{
}
</code> Using closures: <code>
function ClassA()
{
	this.method1 = function ClassA$method1()
	{
	}
}
</code>

  * When defining objects using a shorthand notation, unlike defined by JSON format, the properties of the objects will not be in quotes. The quotes are allowed if required in case of special characters.<br>

The use of reserved words is not permitted.<br>

<code>
var o = { type: "button", action: "textbutton", text: "Text Button", "composite.property": false };
</code>

== Code formatting ==

  * Group related code lines together; or in other words, separate different things in code with a blank line.
  * Add an empty line after each function definition
  * Use tabs for indenting and spaces for formatting 
  ** Tabs use a single character and can be configured differently on each developer’s machine, according to his or her preference.
  ** When formatting code, it is important to keep in mind that because the amount of spaces a tab takes is relative, certain formatting can look ‘wrong’ in another developers editor.

WRONG: <code>
// you format your code to align nicely using 4-space tabs:
var item          = "Item 1";
var x             = "Item 015";
var somethingElse = "Item 46";
var blue          = "45";
var red           = "177";
</code>

WRONG: <code>
// another developer that uses 2-spaces tabs opens the file and sees this:
var item          = "Item 1";
var x       = "Item 015";
var somethingElse = "Item 46";
var blue       = "45";
var red        = "177";
</code>

RIGHT: <code>
var item = "Item 1";
var x = "Item 015";
var somethingElse = "Item 46";
var blue = "45";
var red = "177";
</code>

  * Spell out your intention clearly, rather then to compress logic in 'smart' statements:

WRONG: <code>
x().doStuff(x != 1 ? true : false, y != 2);
</code> BETTER: <code>
var instance = x();
var useGreen = x != 1 ? true : false;
var usePurple = y != 2;
instance.doStuff(useGreen, usePurple);
</code>

  * Space before and after each binary and ternary operator ( =, +, -, `<`, `>`, `*`, /, ? :, etc.)

<code>
var x = 10;
x += 2;
y = x % 2 == 0 ? 10 : 30;
</code> 
No space before semicolon: <code>
fox.jump();
u = w / 4;
</code> 
No space around unary operators: <code>
y++;
</code> 
No space after an opening and before a closing bracket: <code>
x.subtract(45);
for (var name in colors) { ... }
t = y.substring(0, 10);
</code> 
No space before, one space after a comma:
<code>
function Object$convert(value1, value2) { ... }
</code>

  * Have a space between if/for/while/do and an opening bracket.
  * Break long lines (longer than about 120 character positions) into shorter lines.
  * When breaking lines and specifying a number of arguments to a function add an extra TAB to indent the arguments:

==== Curly braces ====

Curly braces are required when defining a block of code (after statements such as for, while, do, if, etc.), even when the block consists of a single line. The braces must be on their own line, aligned with the statement that starts the block. <code>
for (var i = 0; i < 10; i++)
{
	a.push(i);
}
</code>

When defining an object on a single line curly braces may be on the same line, with a space after the opening brace and a space before the closing brace. <code>
var o = { prop1: value1, prop2: value2 };
</code>

=== Shorthand notations ===

Preferably use shorthand notations unless it reduces clarity of the code. For instance:

<code>
if (obj1)
{
    res = obj1;
}
else
{
    res = obj2;
}
</code> 

Should be written as: <code>
res = obj1 || obj2;
</code>

Whereas:
<code>
if (typeof(par) == "undefined" || par == null)
{
...
}
</code>

Will be more concise (and cover more cases of ''par'' being not an object) if written as: <code>
if (!par)
{
...
}
</code>

== Code commenting ==
*The Pragmatic Programmer*, _Andrew Hunt, David Thomas_: 
   [...] keep the low-level knowledge in the code, where it belongs, and reserve the comments for other, high-level explanations. 
   Otherwise, we're duplicating knowledge, and every change means changing both the code and the comments. 
   The comments will inevitably become out of date, and untrustworthy comments are worse than no comments at all. 
   [...] Code should have comments, but too many comments can be just as bad as too few. In general, comments should discuss why something is done, its purpose and its goal. The code already shows how it is done, so commenting on this is redundant.

  * Document your functions using JDoc tags

<code>
{{{
/**
 * Provides the information about a list.
 * @param {List} listControl Reference to the list control that this definition is a part of.
 * @param {XmlDocument} definitionDoc An xml document that contains the definition of the list.
 */
Tridion.Controls.ListDefinition = function ListDefinition(listControl, definitionDoc)
{
  this.properties = {};
  /**
   * Holds the reference to the list control that this definition is a part of.
   * @type {Tridion.Controls.List}
   */
  this.properties.control = listControl;
}
}}}
</code>

  * Do not comment out code 'temporarily'. Those 'temporary' comments tend to outlive the employment of the developer who put them there. Just remove the code and put any information you want to pass on to the source control system when checking-in the changes.

== Validation/Error handling<br> ==

  * Use methods defined in Types.js to check for the type of input arguments, return values, etc., instead of using _typeof(object)_
    ** Type.isArray
    ** Type.isDate
    ** Type.isBoolean
    ** Type.isNumber
    ** ...

  * Always use assert methods to validate input parameters, for example: <code>$assert.isArray(par1)</code>
  * Do not use <code>throw Error("...")</code> to throw errors. Use a specialized method for raising errors: <code>$assert.raiseError("...");</code>
  * Do not use alert() to show errors. Use a specialized method for logging/handling errors.
  * Avoid using alert() and confirm(). Implement wrappers for these and use them.

== Best practices ==

=== Iterating ===

Performing lengthy operations in a loop is a typical source of performance problems.

When iterating through an array or a collection, store the upper bound of the list in a local variable instead of evaluating it after each iteration:

LESS OPTIMAL: <code>
for (var i = 0; i < list.length; i++)
{
    ...
}
</code>

BETTER: <code>
for (var i = 0, len = list.length; i < len; i++)
{
    ...
}
</code>

If an item is being accessed multiple times in an iteration, cache it in a local variable instead of resolving it several times using its index (which might be a very expensive operation)

LESS OPTIMAL: <code>
{{{
for (var i = 0, len = list.length; i < len; i++)
{
    list[i].do1(...);
    list[i].do2(...);
}
}}}
</code>

BETTER: <code>
{{{
for (var i = 0, len = list.length; i < len; i++)
{
    var item = list[i];
    item.do1(...);
    item.do2(...);
}
}}}
</code> <br>

=== Node Lists ===

Accessing an element by an index in a long node list can be costly. Sometimes it can be optimized by using direct node references.

Consider the following example that loops through all child nodes of an element and adds them to an array: <code>
{{{
var a = [];
var nodes = xmlNode.childNodes;
var length = nodes.length;
for (var i=0; i < length; i++)
      {
            a.push(nodes[i]);
      }
}}}
</code> Alternatively it can be rewritten like this: <code>
{{{
var a = [];
var node = xmlNode.firstChild;
if (node)
{
    do
    {
        a.push(node);
        node = node.nextSibling;
    }
    while(node);
}
}}}
</code> 

On 10,000 items in IE the latter version is about 10 times faster. In FireFox the difference isn’t that big, about 10%. IE simply couldn’t handle 100,000 items when using an index, but when using nextSibling it outperformed FireFox by 3.5 times.



=== Local variables ===

Local variables are considerably faster in access then object properties. When the same property is being accessed multiple times, it makes sense to have it in a local variable. <code>
function()
{
    var p = this.properties;
    p.prop1 = ...;
    p.prop2 = ...;
}
</code>

It is even faster to cache a ''document'' object in a local variable and use that, if it is being accessed many times. It's because ''document'' is in fact a property of a ''window'' object, thus is resolved using ''window.document'', which is slower than accessing a local variable.

=== Redundant code ===

Avoid redundant code. For instance in the following snippet the initial initialization of a variable is not always needed: <code>
{{{
string ret = AppDomain.CurrentDomain.BaseDirectory;
if (HttpContext.Current != null)
{
    ret = HttpContext.Current.Request.ApplicationPath;
}
}}}
</code> 
A better code would be: <code>
{{{
string ret;
if (HttpContext.Current != null)
{
    ret = HttpContext.Current.Request.ApplicationPath;
}
else
{
    ret = AppDomain.CurrentDomain.BaseDirectory
}
}}}
</code>

=== String manipulation ===

String concatenation is slow. In IE it's ridiculously slow. Keep in mind the possibility of pushing pieces of a string into an array and then calling _.join('')_.

On a test machine the following code took some 690 milliseconds in FireFox and 490 milliseconds in Chrome with NUM=1000, and it took about 15 seconds in IE with NUM=200. It took several hours in IE with NUM=1000. <code>
{{{
var s = "<table>";
for (var i = 0; i < NUM; i++)
{
    s += "<tr>"
    for (var j = 0; j < NUM; j++)
    {
        s += "<td>X</td>"
    }
    s += "</tr>"
}
s += "</table>";
}}}
</code> 

The following code was slightly slower in FF (720 milliseconds with NUM=1000), faster in Chrome (310 milliseconds with NUM=1000), and considerably faster in IE (170 milliseconds with NUM=200, and 4.4 seconds with NUM=1000) <code>
{{{
var a = ["<table>"];
for (var i = 0; i < NUM; i++)
{
	a.push("<tr>");
	for (var j = 0; j < NUM; j++)
	{
		a.push("<td>X</td>")
	}
	a.push("</tr>");
}
a.push("</table>");
s = a.join("");
}}}
</code> 

For comparison, the code below (though difficult to understand but doing the same task) took about 400 milliseconds in FF, 15 milliseconds in Chrome, and 140 milliseconds in IE (all with NUM=1000). <code>
{{{
var a = new Array(NUM+1);
var s1 = "<tr>" + a.join("<td>X</td>", "") + "</tr>";
var s = "<table>" + a.join(s1, "") + "</table>";
}}}
</code>

=== Browser detection vs. Object detection ===

Avoid doing browser detection for determining which method to call. Use DOM method detection instead.

WRONG: <code>
{{{
if ($dom.isIE)
{
	return elem.ownerDocument.parentWindow;
}
else
{
	return elem.ownerDocument.defaultView;
}
}}}
</code> RIGHT: <code>
{{{
if (elem.ownerDocument.parentWindow)
{
	return elem.ownerDocument.parentWindow;
}
else
{
	return elem.ownerDocument.defaultView;
}
}}}
</code> 
or a shorter version: <code>
{{{
return elem.ownerDocument.parentWindow || elem.ownerDocument.defaultView;
}}}
</code> 

This code will support any possible non-IE browsers that implement _.parentWindow_ property.

Browser detection should be used only when working around known problems/bugs with specific browsers or in the case of inconsistent behavior of the same method in different browsers.

== Using Domain Model ==

  * Do not cache objects that implement ''Tridion.MarshallableObject'' in member variables. This is because a marshallable object can be moved to another instance, thus invalidating the previous reference.

Use _Tridion.ContentManager.Model.getItem(id)_ to get the reference when it's needed.

WRONG: <code>
{{{
var page = Tridion.ContentManager.Model.getItem("tcm:1-2-64");
function checkIn()
{
   page.checkIn();
}
}}}
</code> RIGHT: <code>
{{{
function checkIn()
{
   var page = Tridion.ContentManager.Model.getItem("tcm:1-2-64");
   page.checkIn();
}
}}}
</code>

  * Avoid using and manipulating internal properties and xml of items in the domain model. Always use the API provided by the model. If access to some functionality is missing from the API it's not an excuse to have hardcoded xpath strings in your code, but a good reason to extend the API.

= HTML/ASPX =

  * Within the html document, you need to declare the DOCTYPE set to ‘transitional’
<code>
{{{
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
}}}
</code> 
  * All aspx page must have <code>xmlns:c="http://www.sdltridion.com/web/ui/controls"</code> defined, as some of our controls use custom client-side attributes with "c" prefix.
  * Use lowercase ''id'' attribute name for client side HTML elements
  * Use uppercase ''ID'' attribute name for server side ASP.NET controls
  * Specify ''id'' and ''ID'' only when necessary and use meaningful values (make sure to remove ID's that are auto-generated by Visual Studio).


= CSS =

== Targeting Specific Browsers ==

To support browser specific styles, the core adds one or more a classes to the document's HTML element to identify the browser. 

For example, when using Internet Explorer 7, the classes _ie_ and _ie7_ are set on the HTML element. Therefore, any CSS properties that should be set only for Internet Explorer should use _.ie_ before any other selectors. For example:
<code>
.ie input
{
   outline: none;
}
</code>

The browser-specific classes added to the HTML element are:
  * Internet Explorer 7: ie and ie7
  * Internet Explorer 8: ie
  * Firefox: gecko
  * Chrome and Safari: webkit

== Code Guidelines ==

The following fragment illustrates the coding style to be used for CSS. Note that to improve legibility each property should appear on a separate line.
<code>
{{{
.dropdown .arrow
{
   min-height: 14px;
   min-width: 14px;
   background-image: url(Images/Controls/Dropdown/down.png);
   background-repeat: no-repeat;
   padding: 0px;
   margin: 0px;
}
}}}
</code>